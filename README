Index
=====

Part A:
1. Introduction
2. Legal notice
3. Testbench

Part B:
01. 1 bit register (register1.vhd)
02. N bit register (register.vhd)
03. Shift register (shift_reg.vhd)
04. Delay register (delay_reg.vhd)
05. Adder (add.vhd)
06. Subtractor (sub.vhd)
07. Accumulator (accumulator.vhd)
08. Counter (counter.vhd)
09. Sine/Cosine look up table (sincos.vhd)
10. Numerically controlled oscillator (nco.vhd)
11. Array adder (array_adder.vhd)
12. Multiplier (mul.vhd)
13. Rounder (round.vhd)
14. IQ demudulator (iqdemod.vhd)
15. Decoder (decode.vhd)
16. Barrel shifter (barrel_shift.vhd)
17. Differentiator (differentiator.vhd)
18. Bidirectional buffer (bidir.vhd)
19. Cascaded integrator comb filter (cic.vhd)
20. Linear feedback shift register (lfsr.vhd)
21. Proportional integral differential controller (pidctrl.vhd)
22. Clock Divider (clkdiv.vhd)
23. Phase locked loop (pll.vhd)
24. Pulse width modulation (pwm.vhd)
25. Serializer (serializer.vhd)
26. Comparator (cmp.vhd)
27. Demultiplexer (demux.vhd)
28. Multi-bit shift register (multi_shift_reg.vhd)
29. Butterfly (butterfly.vhd)
30. Multiplexer (mux.vhd)


Part A
======

1. Introduction
---------------

This folder contains various extremly useful generic VHDL compoments.
Documentation for each component can be found in the following sections.
If you add a component, you have to conform to the existing coding conventions
and you have to append a section to this document. If you fail to do so, your
component will be deleted without further notice.


2. Legal notice
---------------

Copyright (c) 2012, Nils Christopher Brause
All rights reserved.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

The views and conclusions contained in the software and documentation are
those of the authors and should not be interpreted as representing official
policies, either expressed or implied, of the Max Planck Institute for
Gravitational Physics (Albert Einstein Institute).


3. Testbench
------------

If you have the free open source VHDL simulator GHDL installed you can run the
provided thestbench to test the included components. In a shell type
"make ghdl" and press Enter to do so. You can view th generated waveforms with
the free open source waveform viewer GTKWave.
The testbench itself can be found in the file testbench.vhd. Please note that
the PLL has a separate testbench calles testbench_pll.vhd.


Part B
======

01. 1 bit register (register1.vhd)
----------------------------------

A 1 bit register can store 1 bit of information.
It can be used for e.g. reset synchronization.

Component declaration:

  component reg1 is
    port (
      clk      : in  std_logic;
      reset    : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic;
      data_out : out std_logic);
  end component reg1;

Schematic:

   +------------------+
---| clk     data_out |---
---| reset            |
---| enable           |
---| data_in          |
   +------------------+

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- data_in: data input
- data_out: data output

Logic lable:

reset | clk  | enable | data_in | data_out
------+------+--------+---------+---------
high  | rise | high   | high    | high
high  | rise | high   | low     | low
high  | rise | low    | dnc     | last
high  | fall | dnc    | dnc     | last
low   | dnc  | dnc    | dnc     | low

"dnc" means "do not care".


02. N bit register (register.vhd)
---------------------------------

A N bit register can store N bit of information.
It works exactly as the 1 bit register but with N bits.

Component declaration:

  component reg is
    generic (
      bits : natural); 
    port (
      clk      : in  std_logic;
      reset    : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic_vector(bits-1 downto 0);
      data_out : out std_logic_vector(bits-1 downto 0)); 
  end component reg;

Schematic:

   +------------------+
---| clk     data_out |===
---| reset            |
---| enable           |
===| data_in          |
   +------------------+

The "="-symbol denotes a bus.

Generic description:

- bits: denotes the number of bits to be stored.

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- data_in: data input
- data_out: data output


03. Shift register (shift_reg.vhd)
----------------------------------

A shift register can be used to parallelize a serial signal or serialize a
parallel signal. With every clock cycle the Nth bits is put on the seril output
and replaced by the N-1th bit, the 1..N-1th bit is replaced by the 0..N-2nd bit
and the 0th bit is replaced by the serial input. If load is asserted the
contents of the registers are replaced by the value of parallel_in.

Component declaration:

  component shift_reg is
    generic (
      bits : natural);
    port (
      clk          : in  std_logic;
      reset        : in  std_logic;
      load         : in  std_logic;
      serial_in    : in  std_logic;
      serial_out   : out std_logic;
      parallel_in  : in  std_logic_vector(bits-1 downto 0);
      parallel_out : out std_logic_vector(bits-1 downto 0);
      enable       : in  std_logic);
  end component shift_reg;

Schematic:

   +------------------------+
---| clk       serial_out   |---
---| reset     parallel_out |===
---| load                   |
---| enable                 |
---| serial_in              |
===| parallel_in            |
   +------------------------+

Generic description:

- bits: denotes the number of bits to be stored

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- load: load the the value from parallel_in
- enable: enable pin
- serial_in: serial data input
- parallel_in; parallel data input
- serial_out: serial data output
- parallel_out: parallel data output


04. Delay register (delay_reg.vhd)
----------------------------------

A delay register works just like a normal N bit register, but the delay
generated by the delay register can be adjusted to suit your needs.

Component declaration:

  component delay_reg is
    generic (
      bits  : natural;
      delay : natural);
    port (
      clk      : in  std_logic;
      reset    : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic_vector(bits-1 downto 0);
      data_out : out std_logic_vector(bits-1 downto 0));
  end component delay_reg;

Schematic:

   +------------------+
---| clk     data_out |===
---| reset            |
---| enable           |
===| data_in          |
   +------------------+

Generic description:

- bits: denotes the number of bits to be stored
- delay: denotes the delay to be generated

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- data_in: data input
- data_out: data output


05. Adder (add.vhd)
-------------------

This adder adds two signed or unsigned numbers and outputs the result. It also
includes carry logic and signed overflow detection.

Component declaration:

  component add is
    generic (
      bits : natural;
      use_kogge_stone : bit);
    port (
      input1    : in  std_logic_vector(bits-1 downto 0);
      input2    : in  std_logic_vector(bits-1 downto 0);
      output    : out std_logic_vector(bits-1 downto 0);
      carry_in  : in  std_logic;
      carry_out : out std_logic;
      overflow  : out std_logic);
  end component add;

Schematic:

   +--------------------+
===| input1   output    |===
===| input2   carry_out |---
---| carry_in overflow  |---
   +--------------------+

Generic description:

- bits: denotes the width of the adder
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- input1: first summand
- input2: second summand
- output: sum of input1, input2 and carry_in
- carry_in: carry input
- carry_out: carry output or unsigned overflow indicator
- overlfow: signed overflow indicator


06. Subtractor (sub.vhd)
------------------------

A subtractor subtracts two unsigned or signed numbers and outputs the result.
It also includes borrow logic and signed underflow detection.

Component declaration:

  component sub is
    generic (
      bits : natural;
      use_kogge_stone : bit);
    port (
      input1     : in  std_logic_vector(bits-1 downto 0);
      input2     : in  std_logic_vector(bits-1 downto 0);
      output     : out std_logic_vector(bits-1 downto 0);
      borrow_in  : in  std_logic;
      borrow_out : out std_logic;
      underflow  : out std_logic);
  end component sub;
  
Schematic:

   +----------------------+
===| input1    output     |===
===| input2    borrow_out |---
---| borrow_in underflow  |---
   +----------------------+

Generic description:

- bits: denotes the width of the subtractor
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- input1: minuend
- input2: subtrahend
- output: difference of input1, input2 and borrow_in
- borrow_in: borrow input
- borrow_out: borrow output or unsigned underflow indicator
- underlfow: signed underflow indicator


07. Accumulator (accumulator.vhd)
---------------------------------

An accumulator accumulates its input value at every clock cycle. The resulting
accumulated value is put out. If it reaches its maximal value it overflows.

Component declaration:

  component accumulator is
    generic (
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      input  : in  std_logic_vector(bits-1 downto 0);
      output : out std_logic_vector(bits-1 downto 0));
  end component accumulator;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
---| enable        |
===| input         |
   +---------------+

Generic description:

- bits: denotes the width of the accumulator
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- input: values to accumulate
- output: accumulated value


08. Counter (counter.vhd)
-------------------------

A counter can count either upwards or downwards eath clock cycle.
If it reaches its maximal value it restarts at zero.

Component declaration:

  component counter is
    generic (
      bits            : natural;
      direction       : bit;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      output : out std_logic_vector(bits-1 downto 0));
  end component counter;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
---| enable        |
   +---------------+

Generic description:

- bits: denotes the width of the counter (and therfore its maximum value)
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')
- direction: Denotes the counter direction. '0' is down and '1' is up.

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- output: counter output


09. Sine/Cosine look up table (sincos.vhd)
------------------------------------------

This look up table implements the sine/cosine functions. This can be used to
implement e.g. a numerically controlled oszillator. Before using the look up
table if first must be generated with the makelut.cpp program. See the Makefile
for example useage.

Component declaration:

  component sincos is
    generic (
      phase_bits : natural;
      bits       : natural);
    port (
      phase : in  std_logic_vector(phase_bits-1 downto 0);
      sin   : out std_logic_vector(bits-1 downto 0);
      cos   : out std_logic_vector(bits-1 downto 0));
  end component sincos;
  
Schematic:

   +--------------+
===| phase sine   |===
   |       cosine |===
   +--------------+

Generic description:

- phase_bits: denotes the with of the input phase
- bits: denotes the width of the outputs

Port description:

- phase: phase angle input
- sine: sine function output
- cosine: cosine function output

10. Numerically controlled oscillator (nco.vhd)
-----------------------------------------------

A numerically controlled oszillator can generate a sinosoidal signal of
arbitrary frequency. It can be used in a direct digital synthesizer.

Component declaration:

  component nco is
    generic (
      pir_bits        : natural;
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk   : in  std_logic;
      reset : in  std_logic;
      pir   : in  std_logic_vector(pir_bits-1 downto 0);
      sin   : out std_logic_vector(bits-1 downto 0);
      cos   : out std_logic_vector(bits-1 downto 0));
  end component nco;
  
Schematic:

   +-----------+
---| clk   sin |===
---| reset cos |===
===| pir       |
   +-----------+

Generic descriptuion:

- pir_bits: denotes the with of the frequency input
- bits: denotes the width of the outputs
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- pir: frequency input
- sin: sine output
- cos: cosine output

11. Array adder (array_adder.vhd)
---------------------------------

If you want to add a lange number of values, the most efficient way to do this
is in a tree. This array adder does exactly this.
On slow FPGAs you can enable the use of registers afer every adder. Then and
only then you have to supply a clock and reset signal.
Please note that the array adder has no carry or overflow logic.

Component declaration:

  component array_adder is
    generic (
      bits            : natural;
      width           : natural;
      signed_arith    : bit;
      use_registers   : bit;
      use_kogge_stone : bit);
    port (
      clk   : in  std_logic;
      reset : in  std_logic;
      data  : in  std_logic_vector(width*bits-1 downto 0);
      sum   : out std_logic_vector(width-1+bits-1 downto 0));
  end component array_adder;

Schematic:

   +-----------+
---| clk   sum |===
---| reset     |
===| data      |
   +-----------+

Generic descriptuion:

- bits: denotes the width of one input value
- width: denotes the number of input values
- signed_arith: use sigend arithmetic
- use_registers: use registers after every adder
                 (for slow FPGAs)
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- data: combined input values
- sum: sum output


12. Multiplier (mul.vhd)
------------------------

The multiplier can mutiply signed or unsigned numbers.

Component declaration:

  component mul is
    generic (
      bits1           : natural;
      bits2           : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      input1 : in  std_logic_vector(bits1-1 downto 0);
      input2 : in  std_logic_vector(bits2-1 downto 0);
      output : out std_logic_vector(bits1+bits2-1 downto 0));
  end component mul;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
===| input1        |
===| input2        |
   +---------------+

Generic description:

- bits1: denotes the width of the first input value
- bits2: denotes the width of the second input value
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- input1: first input value
- input2: second input value
- output: product output


13. Rounder (round.vhd)
-----------------------

The rounder does arithmetic rounding of signed and unsigned integers
without overflowing.
Please note that no rounding occures is outp_bits >= inp_bits.

Component declaration:

  component round is
    generic (
      inp_bits        : natural;
      outp_bits       : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      input  : in  std_logic_vector(inp_bits-1 downto 0);
      output : out std_logic_vector(outp_bits-1 downto 0));
  end component round;

Schematic:

   +--------------+
===| input output |===
   +--------------+

Generic description:

- inp_bits: denotes the width of the input
- outp_bits: denotes the desired width of the output
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- input: input value
- output: rounded output


14. IQ demudulator (iqdemod.vhd)
--------------------------------

The IQ demudulator is a Frequency downconverter which converts a QAM modulated
high frequency signal into two intermediate frequency signal, which are
90 degree out of phase (I and Q).

Component declaration:

  component iqdemod is
    generic (
      bits            : natural;
      nco_bits        : natural;
      freq_bits       : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      clk   : in  std_logic;
      reset : in  std_logic;
      input : in  std_logic_vector(bits-1 downto 0);
      freq  : in  std_logic_vector(freq_bits-1 downto 0);
      i     : out std_logic_vector(bits+nco_bits-1 downto 0);
      q     : out std_logic_vector(bits+nco_bits-1 downto 0));
  end component iqdemod;

Schematic:

   +---------+
---| clk   i |===
---| reset q |===
===| input   |
===| freq    |
   +---------+

Generic description:

- bits: denotes the width of the input signal
- nco_bits: denotes the width of the internal NCO
- freq_bits: denotes the width of the frequency value
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- input: input signal
- freq: demodulation frequency
- i: in phase signal
- q: quadrature signal


15. Decoder (decode.vhd)
-----------------------------------

A decoder calculates two to the power of the input signal.

Component declaration:

  component decoder is
    generic (
      bits : natural);
    port (
      input  : in  std_logic_vector(bits-1 downto 0);
      output : out std_logic_vector(2**bits-1 downto 0));
  end component decoder;

Schematic:

   +--------------+
===| input output |===
   +--------------+

Generic description:

- bits: denotes the width of the input signal

Port description:

- input: input value
- output: decoded output value


16. Barrel shifter (barrel_shift.vhd)
-------------------------------------

A barrel shifter shifts the digits of a binary number in an give direction by a
given amount. It therefore does a cheap multiplication by two to the power of
the amount of bits being shifted.

Component declaration:

  component barrel_shift is
    generic (
      bits         : natural;
      signed_arith : bit); 
    port (
      input  : in  std_logic_vector(bits-1 downto 0);
      amount : in  std_logic_vector(log2ceil(bits) downto 0);
      output : out std_logic_vector(bits-1 downto 0)); 
  end component barrel_shift;

Schematic:

   +----------------+
===| input   output |===
===| amounnt        |
   +----------------+

Generic description:

- bits: denotes the width of the input signal
- signed_arith: use sigend arithmetic
                   (default = '1')

Port description:

- input: input value
- amount: number of bits to shift (in signed 2's complement - positive numbers
          shift to the left, negative numbers shift to the right)
- output: shifted output value


17. Differentiator (differentiator.vhd)
---------------------------------------

The differentiator alwys outputs th difference between the last two input
values.

Component declaration:

  component differentiator is
    generic (
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      input  : in  std_logic_vector(bits-1 downto 0);
      output : out std_logic_vector(bits-1 downto 0));
  end component differentiator;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
---| enable        |
===| input         |
   +---------------+

Generic description:

- bits: denotes the width of the differentiator
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- input: values to differentiate
- output: differentiated value

18. Bidirectional buffer (bidir.vhd)
------------------------------------

A bidirectional buffer can be used to interface with an inout-signal.

Component declaration:

  component bidir is
    generic (
      bits : natural);
    port (
      pins   : inout std_logic_vector(bits-1 downto 0);
      output : in    std_logic_vector(bits-1 downto 0);
      input  : out   std_logic_vector(bits-1 downto 0);
      dir    : in    std_logic);
  end component bidir;

Schematic:

          ||
   +--------------+
   |     pins     |
===| output input |===
---| dir          |
   +--------------+

Generic description:

- bits: denotes the width of the buffer

Port description:

- pins: connect to inout signal
- output: value to be put on pins if dir = '0'
- input: value read from pins if dir = '1'
- dir: direction of pins. Input = '1', Output = '0'


19. Cascaded integrator comb filter (cic.vhd)
---------------------------------------------

A CIC-filter can be used to convert a signal from one samplerate s to another
samplerate s/2^r without aliasing. The number of samples fer filter stage is
fixed to one at the moment, but the number of filter stages is configurable.

Component declaration:

  component cic is
    generic (
      bits            : natural;
      r               : natural;
      n               : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      clk     : in  std_logic;
      clk2    : in  std_logic;
      reset   : in  std_logic;
      input   : in  std_logic_vector(bits-1 downto 0);
      output  : out std_logic_vector(bits-1 downto 0);
      output2 : out std_logic_vector(n*r+bits-1 downto 0));
  end component cic;

Schematic:

   +---------------+
---| clk   output  |===
---| clk2  output2 |===
---| reset         |
===| input         |
   +---------------+

Generic description:

- bits: denotes the width of the input signal
- r: samplerate divider (see description)
- n: denotes the number of filter stages
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock of the input signal (frequency f)
- clk2: clock of the output signal (must have frequency f/2^r)
- reset: asynchronous reset (active low)
- input: input signal
- output: filtered output signal with the same width of the input signal
- output2: fill width filtered output signal


20. Linear feedback shift register (lfsr.vhd)
---------------------------------------------

The linear feedbash shift register (short 'LFSR') can be used to generate
random numbers with up to 168 bits length.

Component declaration:

  component lfsr is
    generic (
      bits : natural);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      output : out std_logic_vector(bits-1 downto 0));
  end component lfsr;

Schematic:

   +--------------+
---| clk   output |===
---| reset        |
   +--------------+

Generic description:

- bits: denotes the desired width of the output

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- output: random nnumber output


21. Proportional integral differential controller (pidctrl.vhd)
---------------------------------------------------------------
This is a standard PID controller as found in many control loops. You can
adjust each gain separatly and also apply a pre-gain to prevent overflows.

Component declaration:

  component pidctrl is
    generic (
      bits            : natural;
      int_bits        : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      clk     : in  std_logic;
      reset   : in  std_logic;
      input   : in  std_logic_vector(bits-1 downto 0);
      pregain : in  std_logic_vector(log2ceil(int_bits) downto 0);
      pgain   : in  std_logic_vector(log2ceil(int_bits) downto 0);
      igain   : in  std_logic_vector(log2ceil(int_bits) downto 0);
      dgain   : in  std_logic_vector(log2ceil(int_bits) downto 0);
      output  : out std_logic_vector(bits-1 downto 0));
  end component pidctrl;

Schematic:

   +----------------+
---| clk     output |===
---| reset          |
===| input          |
===| pregain        |
===| pgain          |
===| igain          |
===| dgain          |
   +----------------+

Generic description:

- bits: denotes the width of the input signal
- int_bits: denotes the width of the internal signals
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- input: input signal
- pregain: pre-gain input
- pgain: gain of the proportional controller
- igain: gain of the integral controller
- dgain: gain of the differential controller
- output: controlled output signal


22. Clock Divider (clkdiv.vhd)
------------------------------

A clock divider can be used to generate a slower clock from a fast clock by
dividing its frequency by some N.

Component declaration:

  component clkdiv is
    generic (
      div             : natural;
      duty_cycle      : bit;
      use_kogge_stone : bit);
    port (
      clk     : in  std_logic;
      reset   : in  std_logic;
      enable  : in  std_logic;
      clk_out : out std_logic);
  end component clkdiv;

Schematic:

   +----------------+
---| clk    clk_out |---
---| reset          |
---| enable         |
   +----------------+

Generic description:

- div: clock divider. Divides the frequency by div+1.
- duty_cycle: Duty cycle. 0 = almost 0%, 1 = about 50%
              (default = '0')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- clk_out: divided clock output


23. Phase locked loop (pll.vhd)
-------------------------------

A phase locked loop (PLL) is a control loop, which lets you track the phase
(and therefore the ferquency) of a sinusoidal signal. For more information
see: GARDNER, FLOYD M.: Phaselock Techniques. WILEY INTERSCIENCE, 2005.

Component declaration:

  component pll2 is
    generic (
      bits            : natural;
      int_bits        : natural;
      nco_bits        : natural;
      freq_bits       : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      clk        : in  std_logic;
      reset      : in  std_logic;
      input      : in  std_logic_vector(bits-1 downto 0);
      i          : out std_logic_vector(bits+nco_bits-1 downto 0);
      q          : out std_logic_vector(bits+nco_bits-1 downto 0);
      error      : in  std_logic_vector(bits+nco_bits-1 downto 0);
      pregain    : in  std_logic_vector(log2ceil(int_bits) downto 0);
      pgain      : in  std_logic_vector(log2ceil(int_bits) downto 0);
      igain      : in  std_logic_vector(log2ceil(int_bits) downto 0);
      dgain      : in  std_logic_vector(log2ceil(int_bits) downto 0);
      start_freq : in  std_logic_vector(freq_bits-1 downto 0);
      freq_out   : out std_logic_vector(freq_bits-1 downto 0);
      freq_in    : in  std_logic_vector(freq_bits-1 downto 0));
  end component pll;

Schematic:

   +---------------------+
---| clk        i        |===
---| reset      q        |===
===| input      freq_out |===
===| error               |
===| pregain             |
===| pain                |
===| igain               |
===| dgain               |
===| start_freq          |
===| freq_in             |
   +---------------------+

Generic description:

- bits: denotes the width of the input signal
- int_bits: denotes the width of the internal signals
- nco_bits: denotes the width of the internal NCO
- freq_bits: denotes the width of the frequency value
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- input: input signal
- error: error signal input
        (Connect to q, unless you know what you're doing)
- pregain: pre-gain input
- pgain: gain of the proportional controller
- igain: gain of the integral controller
- dgain: gain of the differential controller
- start_freq: staring frequency for th internal NCO
- freq_in: frequency input  of the internal NCO.
           (Connect to freq_out, unless you know what you're doing)
- i: in phase signal
- q: quadrature signal
- freq_out: the measured current frequency of the input signal.


24. Pulse width modulation (pwm.vhd)
------------------------------------

Pulse width modulation (PWM) can be used as a cheap 1 bit digital to abalog
converter. The digital values are convertet tu pulses of different widths. In
combination with an low pass filter this results in a smooth analog curve.

Component declaration:

  component pwm is
    generic (
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      ratio  : in  std_logic_vector(log2ceil(bits)-1 downto 0);
      output : out std_logic);
  end component pwm;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
---| enable        |
===| ratio         |
   +---------------+

Generic description:

bits: the length of the output pulses
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- ratio: PWM ratio/DAC input
- output: PWM output


25. Serializer (serializer.vhd)
-------------------------------

This serializer can serialize a parallel signal for targets that need two
clocks (bit clock and byte clock).

Component declaration:

  component serializer is
    generic (
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      input  : in  std_logic_vector(bits-1 downto 0);
      clk1   : out std_logic;
      clk2   : out std_logic;
      ser    : out std_logic);
  end component serializer;

Schematic:

   +-------------+
---| clk    clk1 |---
---| reset  clk2 |---
---| enable ser  |---
===| input       |
   +-------------+

Generic description:

- bits: denotes the width of the input signal
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')
Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- input: input signal
- clk1: bit clock
- clk2: byte finished clock
- ser: serial data output

26. Comparator (cmp.vhd)
------------------------

The comparator compares two numbers and outputs wether they are equal or
less (signed and unsigned) or none of the two. Every other Comparison can
be constructed from these two.

Component declaration:

  comparator_1: entity work.comparator
    generic map (
      bits            => bits,
      use_kogge_stone => use_kogge_stone)
    port map (
      input1 => input1,
      input2 => input2,
      equal  => equal,
      uless  => uless,
      sless  => sless);

   +--------------+
===| input1 equal |---
===| input2 uless |---
   |        sless |---
   +--------------+

Generic description:

- bits: denotes the width of the input signal
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')
Port description:

- input1: first input
- input2: second input
- equal: wether input1 = input2
- uless: wether unsigned(input1) < unsigned(input2)
- sless: wether signed(input1) < signed(input2)


27. Demultiplexer (demux.vhd)
-----------------------------

A demultiplexer can be used to demultiplex a multiplexed bus. In other words
it selects one specific signal out of many depending on some value.

Component declaration:

  component demultiplex is
    generic (
      bits      : natural;
      code_bits : natural);
    port (
      code   : in  std_logic_vector(code_bits-1 downto 0);
      input  : in  std_logic_vector(2**code_bits*bits-1 downto 0);
      output : out std_logic_vector(bits-1 downto 0));
  end component demultiplex;

Schematic:

   +--------------+
===| code  output |===
===| input        |
   +--------------+

Generic description:

- bits: denotes the width of the input signal
- code_bits: denotes the width of the code signal

Port description:
- code: signal selector
- input: multiplexed input signal
- output: demultiplexed output signal


28. Multi-bit shift register (multi_shift_reg.vhd)
--------------------------------------------------

A multi-bit shift register is a combination of multiple normal single-bit shift
registers with integrated row/column trnasformation.

Component declaration:

  component multi_shift_reg is
    generic (
      bits  : natural;
      bytes : natural);
    port (
      clk          : in  std_logic;
      reset        : in  std_logic;
      load         : in  std_logic;
      serial_in    : in  std_logic_vector(bits-1 downto 0);
      serial_out   : out std_logic_vector(bits-1 downto 0);
      parallel_in  : in  std_logic_vector(bytes*bits-1 downto 0);
      parallel_out : out std_logic_vector(bytes*bits-1 downto 0);
      enable       : in  std_logic);
  end component multi_shift_reg;

Schematic:

   +--------------------------+
---| clk         serial_out   |===
---| reset       parallel_out |===
---| load                     |
===| serial_in                |
===| parallel_in              |
---| enable                   |
   +--------------------------+

Generic description:

- bits: denotes the width of the serial input
- bytes: denotes the number of items to be stored

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- load: load the the value from parallel_in
- enable: enable pin
- serial_in: serial data input
- parallel_in; parallel data input
- serial_out: serial data output
- parallel_out: parallel data output


29. Butterfly (butterfly.vhd)
-----------------------------

A butterfly is an essential part of a fast fourier transformation. Please note
that thsi implementation can at the moment only be used on devices with
hardware multipliers/adders.

Component declaration:

  butterfly_1: entity work.butterfly
    generic map (
      bits       => bits,
      phase_bits => phase_bits)
    port map (
      phase        => phase,
      input1_real  => input1_real,
      input1_imag  => input1_imag,
      input2_real  => input2_real,
      input2_imag  => input2_imag,
      output1_real => output1_real,
      output1_imag => output1_imag,
      output2_real => output2_real,
      output2_imag => output2_imag);

Schematic:

   +--------------------------+
===| input1_real output1_real |===
===| input1_imag output1_imag |===
===| input2_real output2_real |===
===| input2_imag output1_imag |===
===| phase                    |
   +--------------------------+

Generic description:

- bits: denotes the width of the input and output signals
- phase_bits: denotes the width of the phase signal

Port description:

- phase: this is the 'k' from w_k
- input1_real: real part of the first input
- input1_imag: imaginary part of the first input
- input2_real: real part of the second input
- input2_imag: imaginary part of the second input
- output1_real: real part of the first output
- output1_imag: imaginary part of the first output
- output2_real: real part of the second output
- output2_imag: imaginary part of the second output

30. Multiplexer (mux.vhd)
-------------------------

A multiplexer multiplexes a signal into a stream of multiple signals.

Component declaration:

  component multiplex is
    generic (
      bits      : natural;
      code_bits : natural);
    port (
      basein : in  std_logic_vector(2**code_bits*bits-1 downto 0);
      input  : in  std_logic_vector(bits-1 downto 0);
      code   : in  std_logic_vector(code_bits-1 downto 0);
      output : out std_logic_vector(2**code_bits*bits-1 downto 0));
  end component multiplex;

Schematic:

   +---------------+
===| basein output |===
===| input         |
===| code          |
   +---------------+

Generic description:

- bits: denotes the width of the input signal
- code_bits: denotes the width of the code signal

Port description:

- basein: base signal, where the input will be multiplexed into
- input: to be multiplexed signal
- code: signal selector
- output: multiplexed output signal

