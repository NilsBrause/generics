Index
=====

Part A:
1. Introduction
2. Legal notice
3. Testbench

Part B:
01. 1 bit register (register1.vhd)
02. N bit register (register.vhd)
03. Shift register (shift_reg.vhd)
04. Delay register (delay_reg.vhd)
05. Adder (add.vhd)
06. Subtractor (sub.vhd)
07. Accumulator (accumulator.vhd)
08. Counter (counter.vhd)
09. Sine/Cosine look up table (sincos.vhd)
10. Numerically controlled oscillator (nco.vhd)
11. Array adder (array_adder.vhd)
12. Multiplier (mul.vhd)
13. Rounder (round.vhd)
14. IQ demudulator (iqdemod.vhd)
15. Demultiplexer (demultiplex.vhd)
16. Barrel shifter (barrel_shift.vhd)
17. Differentiator (differentiator.vhd)


Part A
======

1. Introduction
---------------

This folder contains various extremly useful generic VHDL compoments.
Documentation for each component can be found in the following sections.
If you add a component, you have to conform to the existing coding conventions
and you have to append a section to this document. If you fail to do so, your
component will be deleted without further notice.


2. Legal notice
---------------

Copyright (c) 2012, Nils Christopher Brause
All rights reserved.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

The views and conclusions contained in the software and documentation are
those of the authors and should not be interpreted as representing official
policies, either expressed or implied, of the Max Planck Institute for
Gravitational Physics (Albert Einstein Institute).


3. Testbench
------------

If you have the free open source VHDL simulator GHDL installed you can run the
provided thestbench to test the included components. In a shell type "make" and
press Enter to do so. You can view th generated waveforms with the free open
source waveform viewer GTKWave.
The testbench itself can be found in the file testbench.vhd.


Part B
======

01. 1 bit register (register1.vhd)
----------------------------------

A 1 bit register can store 1 bit of information.
It can be used for e.g. reset synchronization.

Component declaration:

  component reg1 is
    port (
      clk      : in  std_logic;
      reset    : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic;
      data_out : out std_logic);
  end component reg1;

Schematic:

   +------------------+
---| clk     data_out |---
---| reset            |
---| enable           |
---| data_in          |
   +------------------+

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- data_in: data input
- data_out: data output

Logic lable:

reset | clk  | enable | data_in | data_out
------+------+--------+---------+---------
high  | rise | high   | high    | high
high  | rise | high   | low     | low
high  | rise | low    | dnc     | last
high  | fall | dnc    | dnc     | last
low   | dnc  | dnc    | dnc     | low

"dnc" means "do not care".


02. N bit register (register.vhd)
---------------------------------

A N bit register can store N bit of information.
It works exactly as the 1 bit register but with N bits.

Component declaration:

  component reg is
    generic (
      bits : natural); 
    port (
      clk      : in  std_logic;
      reset    : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic_vector(bits-1 downto 0);
      data_out : out std_logic_vector(bits-1 downto 0)); 
  end component reg;

Schematic:

   +------------------+
---| clk     data_out |===
---| reset            |
---| enable           |
===| data_in          |
   +------------------+

The "="-symbol denotes a bus.

Generic description:

- bits: denotes the number of bits to be stored.

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- data_in: data input
- data_out: data output


03. Shift register (shift_reg.vhd)
----------------------------------

A shift register can be used to parallelize a serial signal. Wieth every clock
cycle the Nth bits is put on the seril output and replaced by the N-1th bit,
the 1..N-1th bit is replaced by the 0..N-2nd bit and the 0th bit is replaced
by the serial input.

Component declaration:

  component shift_reg is
    generic (
      bits : natural);
    port (
      clk          : in  std_logic;
      reset        : in  std_logic;
      serial_in    : in  std_logic;
      serial_out   : out std_logic;
      parallel_out : out std_logic_vector(bits-1 downto 0);
      enable       : in  std_logic);
  end component shift_reg;

Schematic:

   +------------------------+
---| clk       serial_out   |---
---| reset     parallel_out |===
---| enable                 |
---| serial_in              |
   +------------------------+

Generic description:

- bits: denotes the number of bits to be stored

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- serial_in: serial data input
- serial_out: serial data output
- parallel_out: parallel data output


04. Delay register (delay_reg.vhd)
----------------------------------

A delay register works just like a normal N bit register, but the delay
generated by the delay register can be adjusted to suit your needs.

Component declaration:

  component delay_reg is
    generic (
      bits  : natural;
      delay : natural);
    port (
      clk      : in  std_logic;
      reset    : in  std_logic;
      enable   : in  std_logic;
      data_in  : in  std_logic_vector(bits-1 downto 0);
      data_out : out std_logic_vector(bits-1 downto 0));
  end component delay_reg;

Schematic:

   +------------------+
---| clk     data_out |===
---| reset            |
---| enable           |
===| data_in          |
   +------------------+

Generic description:

- bits: denotes the number of bits to be stored
- delay: denotes the delay to be generated

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- data_in: data input
- data_out: data output


05. Adder (add.vhd)
-------------------

This adder adds two signed or unsigned numbers and outputs the result. It also
includes carry logic and signed overflow detection.

Component declaration:

  component add is
    generic (
      bits : natural;
      use_kogge_stone : bit);
    port (
      input1    : in  std_logic_vector(bits-1 downto 0);
      input2    : in  std_logic_vector(bits-1 downto 0);
      output    : out std_logic_vector(bits-1 downto 0);
      carry_in  : in  std_logic;
      carry_out : out std_logic;
      overflow  : out std_logic);
  end component add;

Schematic:

   +--------------------+
===| input1   output    |===
===| input2   carry_out |---
---| carry_in overflow  |---
   +--------------------+

Generic description:

- bits: denotes the width of the adder
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- input1: first summand
- input2: second summand
- output: sum of input1, input2 and carry_in
- carry_in: carry input
- carry_out: carry output or unsigned overflow indicator
- overlfow: signed overflow indicator


06. Subtractor (sub.vhd)
------------------------

A subtractor subtracts two unsigned or signed numbers and outputs the result.
It also includes borrow logic and signed underflow detection.

Component declaration:

  component sub is
    generic (
      bits : natural;
      use_kogge_stone : bit);
    port (
      input1     : in  std_logic_vector(bits-1 downto 0);
      input2     : in  std_logic_vector(bits-1 downto 0);
      output     : out std_logic_vector(bits-1 downto 0);
      borrow_in  : in  std_logic;
      borrow_out : out std_logic;
      underflow  : out std_logic);
  end component sub;
  
Schematic:

   +----------------------+
===| input1    output     |===
===| input2    borrow_out |---
---| borrow_in underflow  |---
   +----------------------+

Generic description:

- bits: denotes the width of the subtractor
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- input1: minuend
- input2: subtrahend
- output: difference of input1, input2 and borrow_in
- borrow_in: borrow input
- borrow_out: borrow output or unsigned underflow indicator
- underlfow: signed underflow indicator


07. Accumulator (accumulator.vhd)
---------------------------------

An accumulator accumulates its input value at every clock cycle. The resulting
accumulated value is put out. If it reaches its maximal value it overflows.

Component declaration:

  component accumulator is
    generic (
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      input  : in  std_logic_vector(bits-1 downto 0);
      output : out std_logic_vector(bits-1 downto 0));
  end component accumulator;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
---| enable        |
===| input         |
   +---------------+

Generic description:

- bits: denotes the width of the accumulator
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- input: values to accumulate
- output: accumulated value


08. Counter (counter.vhd)
-------------------------

A counter can count either upwards or downwards eath clock cycle.
If it reaches its maximal value it restarts at zero.

Component declaration:

  component counter is
    generic (
      bits            : natural;
      direction       : bit;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      output : out std_logic_vector(bits-1 downto 0));
  end component counter;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
---| enable        |
   +---------------+

Generic description:

- bits: denotes the width of the counter (and therfore its maximum value)
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')
- direction: Denotes the counter direction. '0' is down and '1' is up.

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- output: counter output


09. Sine/Cosine look up table (sincos.vhd)
------------------------------------------

This look up table implements the sine/cosine functions. This can be used to
implement e.g. a numerically controlled oszillator. Before using the look up
table if first must be generated with the makelut.cpp program. See the Makefile
for example useage.

Component declaration:

  component sincos is
    generic (
      phase_bits : natural;
      bits       : natural);
    port (
      phase : in  std_logic_vector(phase_bits-1 downto 0);
      sin   : out std_logic_vector(bits-1 downto 0);
      cos   : out std_logic_vector(bits-1 downto 0));
  end component sincos;
  
Schematic:

   +--------------+
===| phase sine   |===
   |       cosine |===
   +--------------+

Generic description:

- phase_bits: denotes the with of the input phase
- bits: denotes the width of the outputs

Port description:

- phase: phase angle input
- sine: sine function output
- cosine: cosine function output

10. Numerically controlled oscillator (nco.vhd)
-----------------------------------------------

A numerically controlled oszillator can generate a sinosoidal signal of
arbitrary frequency. It can be used in a direct digital synthesizer.

Component declaration:

  component nco is
    generic (
      pir_bits        : natural;
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk   : in  std_logic;
      reset : in  std_logic;
      pir   : in  std_logic_vector(pir_bits-1 downto 0);
      sin   : out std_logic_vector(bits-1 downto 0);
      cos   : out std_logic_vector(bits-1 downto 0));
  end component nco;
  
Schematic:

   +-----------+
---| clk   sin |===
---| reset cos |===
===| pir       |
   +-----------+

Generic descriptuion:

- pir_bits: denotes the with of the frequency input
- bits: denotes the width of the outputs
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- pir: frequency input
- sin: sine output
- cos: cosine output

11. Array adder (array_adder.vhd)
---------------------------------

If you want to add a lange number of values, the most efficient way to do this
is in a tree. This array adder does exactly this.
On slow FPGAs you can enable the use of registers afer every adder. Then and
only then you have to supply a clock and reset signal.
Please note that the array adder has no carry or overflow logic.

Component declaration:

  component array_adder is
    generic (
      bits            : natural;
      width           : natural;
      signed_arith    : bit;
      use_registers   : bit;
      use_kogge_stone : bit);
    port (
      clk   : in  std_logic;
      reset : in  std_logic;
      data  : in  std_logic_vector(width*bits-1 downto 0);
      sum   : out std_logic_vector(width-1+bits-1 downto 0));
  end component array_adder;

Schematic:

   +-----------+
---| clk   sum |===
---| reset     |
===| data      |
   +-----------+

Generic descriptuion:

- bits: denotes the width of one input value
- width: denotes the number of input values
- signed_arith: use sigend arithmetic
- use_registers: use registers after every adder
                 (for slow FPGAs)
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- data: combined input values
- sum: sum output


12. Multiplier (mul.vhd)
------------------------

The multiplier can mutiply signed or unsigned numbers.

Component declaration:

  component mul is
    generic (
      bits1           : natural;
      bits2           : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      input1 : in  std_logic_vector(bits1-1 downto 0);
      input2 : in  std_logic_vector(bits2-1 downto 0);
      output : out std_logic_vector(bits1+bits2-1 downto 0));
  end component mul;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
===| input1        |
===| input2        |
   +---------------+

Generic description:

- bits1: denotes the width of the first input value
- bits2: denotes the width of the second input value
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- input1: first input value
- input2: second input value
- output: product output


13. Rounder (round.vhd)
-----------------------

The rounder does arithmetic rounding of signed and unsigned integers
without overflowing.
Please note that no rounding occures is outp_bits >= inp_bits.

Component declaration:

  component round is
    generic (
      inp_bits        : natural;
      outp_bits       : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      input  : in  std_logic_vector(inp_bits-1 downto 0);
      output : out std_logic_vector(outp_bits-1 downto 0));
  end component round;

Schematic:

   +--------------+
===| input output |===
   +--------------+

Generic description:

- inp_bits: denotes the width of the input
- outp_bits: denotes the desired width of the output
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- input: input value
- output: rounded output


14. IQ demudulator (iqdemod.vhd)
--------------------------------

The IQ demudulator is a Frequency downconverter which converts a QAM modulated
high frequency signal into two intermediate frequency signal, which are
90 degree out of phase (I and Q).

Component declaration:

  component iqdemod is
    generic (
      bits            : natural;
      nco_bits        : natural;
      freq_bits       : natural;
      signed_arith    : bit;
      use_kogge_stone : bit);
    port (
      clk   : in  std_logic;
      reset : in  std_logic;
      input : in  std_logic_vector(bits-1 downto 0);
      freq  : in  std_logic_vector(freq_bits-1 downto 0);
      i     : out std_logic_vector(bits+nco_bits-1 downto 0);
      q     : out std_logic_vector(bits+nco_bits-1 downto 0));
  end component iqdemod;

Schematic:

   +---------+
---| clk   i |===
---| reset q |===
===| input   |
===| freq    |
   +---------+

Generic description:

- bits: denotes the width of the input signal
- nco_bits: denotes the width of the internal NCO
- freq_bits: denotes the width of the frequency value
- signed_arith: use sigend arithmetic
                   (default = '1')
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- input: input signal
- freq: demodulation frequency
- i: in phase signal
- q: quadrature signal


15. Demultiplexer (demultiplex.vhd)
-----------------------------------

A demupltiplexer calculates two to the power if the input signal.

Component declaration:

  component demultiplexer is
    generic (
      bits : natural);
    port (
      input  : in  std_logic_vector(bits-1 downto 0);
      output : out std_logic_vector(2**bits-1 downto 0));
  end component demultiplexer;

Schematic:

   +--------------+
===| input output |===
   +--------------+

Generic description:

- bits: denotes the width of the input signal

Port description:

- input: input value
- output: demultiplexed output value


16. Barrel shifter (barrel_shift.vhd)
-------------------------------------

A barrel shifter shifts the digits of a binary number in an give direction by a
given amount. It therefore does a cheap multiplication by two to the power of
the amount of bits being shifted.

Component declaration:

  component barrel_shift is
    generic (
      bits         : natural;
      signed_arith : bit); 
    port (
      input  : in  std_logic_vector(bits-1 downto 0);
      amount : in  std_logic_vector(log2ceil(bits)-1 downto 0);
      output : out std_logic_vector(bits-1 downto 0)); 
  end component barrel_shift;

Schematic:

   +----------------+
===| input   output |===
===| amounnt        |
   +----------------+

Generic description:

- bits: denotes the width of the input signal
- signed_arith: use sigend arithmetic
                   (default = '1')

Port description:

- input: input value
- amount: number of bits to shift (in signed 2's complement - positive numbers
          shift to the left, negative numbers shift to the right)
- output: shifted output value


17. Differentiator (differentiator.vhd)
---------------------------------------

The differentiator alwys outputs th difference between the last two input
values.

Component declaration:

  component differentiator is
    generic (
      bits            : natural;
      use_kogge_stone : bit);
    port (
      clk    : in  std_logic;
      reset  : in  std_logic;
      enable : in  std_logic;
      input  : in  std_logic_vector(bits-1 downto 0);
      output : out std_logic_vector(bits-1 downto 0));
  end component differentiator;

Schematic:

   +---------------+
---| clk    output |===
---| reset         |
---| enable        |
===| input         |
   +---------------+

Generic description:

- bits: denotes the width of the differentiator
- use_kogge_stone: Use an optimized Kogge Stone adder
                   (if no hardware adder is available)
                   (default = '0')

Port description:

- clk: clock input
- reset: asynchronous reset (active low)
- enable: enable pin
- input: values to differentiate
- output: differentiated value

